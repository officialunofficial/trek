<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trek Playground</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@700&display=swap');

        :root {
            --text-primary: #000000;
            --text-secondary: #6e6e73;
            --text-tertiary: #86868b;
            --accent: #007AFF;
            --accent-hover: #0051D5;
            --background: #ffffff;
            --surface: #fafafa;
            --surface-hover: #f0f0f0;
            --border: rgba(0, 0, 0, 0.08);
            --border-hover: rgba(0, 0, 0, 0.16);
            --error: #ff3b30;
            --success: #34c759;
            --radius: 16px;
            --radius-small: 12px;
            --transition: 200ms ease-in-out;
            --topograph-color: rgba(0, 0, 0, 0.12);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --text-primary: #ffffff;
                --text-secondary: #8b8b8d;
                --text-tertiary: #5a5a5c;
                --background: #000000;
                --surface: #1a1a1a;
                --surface-hover: #2a2a2a;
                --border: rgba(255, 255, 255, 0.08);
                --border-hover: rgba(255, 255, 255, 0.16);
                --topograph-color: rgba(255, 255, 255, 0.12);
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 16px;
            line-height: 1.47;
            font-weight: 400;
            letter-spacing: -0.022em;
            color: var(--text-primary);
            background: var(--background);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        .logo {
            margin: 20px 24px 20px 24px;
            height: 60px;
            display: flex;
            align-items: center;
        }

        .logo img {
            height: 100%;
            width: auto;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            height: 100vh;
        }

        .section {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
            border: 1px solid var(--border);
            border-radius: var(--radius-small);
            background: var(--background);
        }

        .input-label {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 12px;
            letter-spacing: 0.01em;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin: 0 24px 16px 24px;
            flex-wrap: wrap;
        }
        
        .url-input {
            flex: 1;
            min-width: 300px;
            padding: 8px 16px;
            border: 1px solid var(--border);
            border-radius: var(--radius-small);
            font-size: 15px;
            background: var(--surface);
            color: var(--text-primary);
            transition: border-color var(--transition);
        }
        
        .url-input:focus {
            outline: none;
            border-color: var(--border-hover);
        }
        
        .url-input::placeholder {
            color: var(--text-tertiary);
        }

        .button {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 16px;
            font-size: 15px;
            font-weight: 500;
            letter-spacing: -0.024em;
            cursor: pointer;
            transition: all var(--transition);
            border-radius: var(--radius-small);
        }

        .button:hover {
            border-color: var(--border-hover);
        }

        .button-primary {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .button-primary:hover {
            background: var(--accent-hover);
            border-color: var(--accent-hover);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .options {
            display: flex;
            gap: 24px;
            margin: 0 24px 16px 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }

        .option {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--accent);
        }

        .editor-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            padding: 0 24px 24px 24px;
        }

        .editor {
            width: 100%;
            flex: 1;
            padding: 24px;
            border: 1px solid var(--border);
            border-radius: var(--radius-small);
            font-family: "SF Mono", Monaco, monospace;
            font-size: 13px;
            line-height: 1.8;
            resize: none;
            background: var(--surface);
            color: var(--text-primary);
            transition: border-color var(--transition);
        }

        .editor:focus {
            outline: none;
            border-color: var(--border-hover);
        }

        .editor::placeholder {
            color: var(--text-tertiary);
        }

        .editor::-webkit-scrollbar {
            display: none;
        }

        .editor {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        .tabs {
            display: flex;
            gap: 32px;
            margin: 20px 24px 32px 24px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .tab {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            letter-spacing: -0.024em;
            cursor: pointer;
            padding: 0;
            position: relative;
            transition: color var(--transition);
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--text-primary);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -13px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent);
        }

        .output-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            position: relative;
        }

        .output {
            flex: 1;
            overflow-y: auto;
            padding: 0 24px 24px 24px;
            min-height: 0;
        }

        .stats-sticky {
            position: sticky;
            bottom: 0;
            background: var(--background);
            border-top: 1px solid var(--border);
            padding: 12px 24px;
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
            z-index: 10;
            display: none;
        }

        .stats-sticky.active {
            display: block;
        }

        .output::-webkit-scrollbar {
            width: 8px;
        }

        .output::-webkit-scrollbar-track {
            background: transparent;
        }

        .output::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .output::-webkit-scrollbar-thumb:hover {
            background: var(--border-hover);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 80px 0;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .loading.active {
            display: block;
        }

        .loading::before {
            content: '';
            display: block;
            width: 20px;
            height: 20px;
            border: 1px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            margin: 0 auto 16px;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error {
            color: var(--error);
            font-size: 14px;
            padding: 16px 0;
        }
        
        .info {
            color: var(--accent);
            font-size: 14px;
            padding: 16px 0;
        }

        .empty {
            text-align: center;
            padding: 80px 0;
            color: var(--text-secondary);
            font-size: 15px;
        }

        .article {
            font-size: 16px;
            line-height: 1.47;
            max-width: 680px;
        }

        .article h1 {
            font-size: 32px;
            font-weight: 700;
            line-height: 1.125;
            margin-bottom: 8px;
            letter-spacing: 0.009em;
        }

        .article .byline {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 32px;
        }

        .article h2 {
            font-size: 24px;
            font-weight: 600;
            margin: 40px 0 16px;
            letter-spacing: 0.009em;
            line-height: 1.16667;
        }

        .article p {
            margin-bottom: 20px;
        }

        .article pre {
            background: var(--surface);
            padding: 20px;
            border-radius: var(--radius-small);
            overflow-x: auto;
            margin: 24px 0;
            font-family: "SF Mono", Monaco, monospace;
            font-size: 13px;
            line-height: 1.6;
            border: 1px solid var(--border);
        }

        .article ul, .article ol {
            margin: 20px 0;
            padding-left: 20px;
        }

        .article li {
            margin-bottom: 8px;
        }

        .metadata {
            display: grid;
            gap: 24px;
        }

        .metadata-item {
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }

        .metadata-label {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .metadata-value {
            font-size: 15px;
            color: var(--text-primary);
            word-break: break-word;
        }

        .json {
            font-family: "SF Mono", Monaco, monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-all;
        }


        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                gap: 48px;
            }

            .controls {
                flex-wrap: wrap;
            }

            .options {
                flex-direction: column;
                gap: 12px;
            }
        }

        /* Topograph styles */
        #topograph-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            opacity: 1;
        }

        .fps-container {
            position: fixed;
            top: 8px;
            right: 8px;
            padding: 0.4rem;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 4px;
            font-size: 11px;
            opacity: 0.6;
            transition: opacity var(--transition);
            z-index: 1000;
        }

        .fps-container:hover {
            opacity: 1;
        }

        .fps-container p {
            all: unset;
            font-weight: bold;
            font-family: 'Nunito', sans-serif;
        }
    </style>
</head>
<body>
    <canvas id="topograph-canvas"></canvas>
    <div class="fps-container" style="display: none;">
        <p id="fps-count"></p>
    </div>
    <div class="container">
        <section class="section">
            <div class="logo">
                <img src="trek.svg" alt="Trek" />
            </div>

            <div class="controls">
                <input type="url" id="urlInput" class="url-input" placeholder="Enter URL to fetch content..." title="Note: Some sites may block fetching due to CORS. Try news sites or blogs.">
                <button class="button" id="fetchBtn" onclick="fetchUrl()">Fetch</button>
                <button class="button button-primary" id="extractBtn" onclick="extractContent()">Extract</button>
                <button class="button" onclick="clearInput()">Clear</button>
                <button class="button" onclick="loadExample()">Example HTML</button>
                <button class="button" onclick="loadExampleUrl()">Example URL</button>
            </div>

            <div class="options">
                <label class="option">
                    <input type="checkbox" id="debugMode" />
                    <span>Debug mode</span>
                </label>
                <label class="option">
                    <input type="checkbox" id="removeClutter" checked />
                    <span>Remove clutter</span>
                </label>
            </div>

            <div class="editor-wrapper">
                <textarea class="editor" id="htmlInput" placeholder="Paste your HTML here..."></textarea>
            </div>
        </section>

        <section class="section">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('metadata')">Metadata</button>
                <button class="tab" onclick="switchTab('content')">Content</button>
                <button class="tab" onclick="switchTab('raw')">Raw</button>
            </div>

            <div class="output-wrapper">
                <div class="output">
                    <div class="loading" id="loading">Processing...</div>
                    <div id="errorContainer"></div>
                    <div id="output">
                        <div class="empty">Your extracted content will appear here</div>
                    </div>
                </div>
                <div id="statsContainer" class="stats-sticky"></div>
            </div>
        </section>
    </div>

    <script type="module">
        import init, { TrekWasm } from '../pkg/trek_rs.js';

        let trek = null;
        let currentTab = 'metadata';
        let lastResult = null;

        async function initializeTrek() {
            try {
                await init();
            } catch (error) {
                console.error('Failed to initialize Trek:', error);
                showError('Failed to initialize Trek. Please refresh the page.');
            }
        }

        window.extractContent = async function() {
            const input = document.getElementById('htmlInput').value.trim();

            if (!input) {
                showError('Please enter HTML to extract');
                return;
            }

            const extractBtn = document.getElementById('extractBtn');
            const loading = document.getElementById('loading');
            const errorContainer = document.getElementById('errorContainer');

            extractBtn.disabled = true;
            loading.classList.add('active');
            errorContainer.innerHTML = '';

            try {
                const debug = document.getElementById('debugMode').checked;
                const removeClutter = document.getElementById('removeClutter').checked;

                if (trek) {
                    trek.free();
                }

                // Get URL from input if available
                const urlInput = document.getElementById('urlInput').value.trim();
                
                trek = new TrekWasm({
                    debug: debug,
                    url: urlInput || null,
                    markdown: false,
                    separateMarkdown: false,
                    removeExactSelectors: removeClutter,
                    removePartialSelectors: removeClutter
                });

                const startTime = performance.now();
                const response = await trek.parse_async(input);
                const endTime = performance.now();

                // Convert to Map for backwards compatibility with display functions
                const result = new Map(Object.entries(response));
                result.set('extractTime', Math.round(endTime - startTime));
                lastResult = result;

                displayResults(currentTab);
                updateStats(result);

            } catch (error) {
                console.error('Extraction error:', error);
                showError(`Extraction failed: ${error.message || error}`);
            } finally {
                extractBtn.disabled = false;
                loading.classList.remove('active');
            }
        };

        function displayResults(tab) {
            const output = document.getElementById('output');

            if (!lastResult) {
                output.innerHTML = '<div class="empty">No results to display</div>';
                return;
            }

            switch (tab) {
                case 'metadata':
                    displayMetadata(output, lastResult);
                    break;
                case 'content':
                    displayContent(output, lastResult);
                    break;
                case 'raw':
                    displayRawJSON(output, lastResult);
                    break;
            }
        }

        function displayContent(container, result) {
            const content = result.get('content');
            const title = result.get('title');
            const author = result.get('author');

            if (!content) {
                container.innerHTML = '<div class="empty">No content extracted</div>';
                return;
            }

            // Content is already HTML, so render it directly
            container.innerHTML = `
                <article class="article">
                    ${title ? `<h1>${escapeHtml(title)}</h1>` : ''}
                    ${author ? `<p class="byline">${escapeHtml(author)}</p>` : ''}
                    <div>${content}</div>
                </article>
            `;
        }

        function displayMetadata(container, result) {
            const items = [];

            const fields = ['title', 'author', 'description', 'site', 'published', 'extractorType'];
            fields.forEach(field => {
                const value = result.get(field);
                if (value) {
                    items.push({
                        label: field,
                        value
                    });
                }
            });

            const metaTags = result.get('metaTags');
            if (metaTags && metaTags.length > 0) {
                metaTags.slice(0, 5).forEach(tag => {
                    const name = tag.name || tag.property || 'meta';
                    items.push({ label: name, value: tag.content });
                });
            }

            if (items.length === 0) {
                container.innerHTML = '<div class="empty">No metadata extracted</div>';
                return;
            }

            container.innerHTML = `
                <div class="metadata">
                    ${items.map(item => `
                        <div class="metadata-item">
                            <div class="metadata-label">${escapeHtml(item.label)}</div>
                            <div class="metadata-value">${escapeHtml(item.value)}</div>
                        </div>
                    `).join('')}
                    ${result.get('debug_info') ? `
                        <div class="metadata-item" style="margin-top: 24px;">
                            <div class="metadata-label">Debug Information</div>
                            <div class="metadata-value"><pre style="font-family: 'SF Mono', Monaco, monospace; font-size: 11px; line-height: 1.5; white-space: pre-wrap; margin: 0; color: var(--text-secondary);">${escapeHtml(result.get('debug_info'))}</pre></div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function displayRawJSON(container, result) {
            const obj = Object.fromEntries(result);
            container.innerHTML = `<pre class="json">${JSON.stringify(obj, null, 2)}</pre>`;
        }

        function updateStats(result) {
            const statsContainer = document.getElementById('statsContainer');
            if (!result) {
                statsContainer.innerHTML = '';
                statsContainer.classList.remove('active');
                return;
            }

            const wordCount = result.get('wordCount') || 0;
            const parseTime = result.get('parseTime') || 0;
            const extractTime = result.get('extractTime') || 0;
            const contentLength = (result.get('content') || '').length;

            statsContainer.innerHTML = `${wordCount} words · ${contentLength} characters · ${parseTime + extractTime}ms`;
            statsContainer.classList.add('active');
        }

        window.switchTab = function(tab) {
            currentTab = tab;

            document.querySelectorAll('.tab').forEach(t => {
                t.classList.remove('active');
            });
            event.target.classList.add('active');

            displayResults(tab);
        };

        window.clearInput = function() {
            document.getElementById('htmlInput').value = '';
            document.getElementById('urlInput').value = '';
            document.getElementById('output').innerHTML = '<div class="empty">Your extracted content will appear here</div>';
            document.getElementById('errorContainer').innerHTML = '';
            document.getElementById('statsContainer').innerHTML = '';
            lastResult = null;
        };
        
        window.fetchUrl = async function() {
            const urlInput = document.getElementById('urlInput');
            const url = urlInput.value.trim();
            
            if (!url) {
                showError('Please enter a URL');
                return;
            }
            
            // Validate URL
            try {
                new URL(url);
            } catch (e) {
                showError('Please enter a valid URL');
                return;
            }
            
            const fetchBtn = document.getElementById('fetchBtn');
            const htmlInput = document.getElementById('htmlInput');
            const loading = document.getElementById('loading');
            const errorContainer = document.getElementById('errorContainer');
            
            fetchBtn.disabled = true;
            loading.classList.add('active');
            errorContainer.innerHTML = '';
            htmlInput.value = 'Fetching content...';
            
            try {
                // Use a public CORS proxy service
                // Alternative proxies if needed:
                // - https://corsproxy.io/?
                // - https://cors-anywhere.herokuapp.com/
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const response = await fetch(proxyUrl + encodeURIComponent(url));
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
                }
                
                const html = await response.text();
                
                if (!html || html.trim().length === 0) {
                    throw new Error('No content received from URL');
                }
                
                // Update the HTML input with fetched content
                htmlInput.value = html;
                
                // Automatically extract content
                await extractContent();
                
            } catch (error) {
                console.error('Fetch error:', error);
                let errorMessage = `Failed to fetch URL: ${error.message}`;
                
                if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
                    errorMessage += `\n\nNote: Due to browser security (CORS), some websites cannot be fetched directly. `;
                    errorMessage += `Try:\n• News sites and blogs often work\n• Copy and paste the HTML source manually\n• Use browser extensions that allow CORS`;
                }
                
                showError(errorMessage);
                htmlInput.value = '';
            } finally {
                fetchBtn.disabled = false;
                loading.classList.remove('active');
            }
        };

        window.loadExampleUrl = function() {
            // Example URLs that typically work with CORS proxies
            const exampleUrls = [
                'https://www.nytimes.com/interactive/2025/06/17/magazine/ai-human-analysis-face-diseases.html',
                'https://www.instyle.com/sardine-girl-summer-fashion-trend-11752920',
                'https://justine.lol/history/',
                'https://mirror80.com/2016/06/wall-street-movie-80s/',
                'https://www.theverge.com/news/689093/waymo-nyc-permit-autonomous-testing-new-york-state'
            ];
            
            const randomUrl = exampleUrls[Math.floor(Math.random() * exampleUrls.length)];
            document.getElementById('urlInput').value = randomUrl;
            document.getElementById('htmlInput').value = '';
            
            // Show a tip
            showError('Click "Fetch" to load content from this URL. Note: Not all sites work due to CORS restrictions.', true);
        };
        
        window.loadExample = function() {
            document.getElementById('htmlInput').value = `<!DOCTYPE html>
<html lang="en">
<head>
    <title>Kafka on the Shore: A Journey Through Parallel Worlds</title>
    <meta name="author" content="Haruki Murakami">
    <meta name="description" content="An exploration of Haruki Murakami's surreal masterpiece that blends reality with metaphysical elements">
    <meta property="og:title" content="Kafka on the Shore: A Journey Through Parallel Worlds">
    <meta property="og:site_name" content="Literary Review Quarterly">
    <meta property="article:published_time" content="2025-06-17T11:00:00Z">
    <meta property="article:section" content="Book Reviews">
    <meta name="keywords" content="Haruki Murakami, Kafka on the Shore, Japanese literature, magical realism">
</head>
<body>
    <nav class="site-navigation">
        <a href="/">Home</a>
        <a href="/reviews">Reviews</a>
        <a href="/authors">Authors</a>
        <a href="/contact">Contact</a>
    </nav>

    <aside class="sidebar">
        <h3>More Murakami</h3>
        <ul>
            <li><a href="/1q84">1Q84: Two Moons in the Sky</a></li>
            <li><a href="/norwegian-wood">Norwegian Wood: A Nostalgic Journey</a></li>
            <li><a href="/wind-up-bird">The Wind-Up Bird Chronicle</a></li>
        </ul>
        <div class="advertisement">Advertisement</div>
    </aside>

    <main>
        <article>
            <header>
                <h1>Kafka on the Shore: A Journey Through Parallel Worlds</h1>
                <p class="byline">By Literary Review Quarterly · June 17, 2025</p>
            </header>

            <p>Haruki Murakami's "Kafka on the Shore" is a mesmerizing odyssey that defies conventional storytelling. Published in 2002, this novel interweaves two distinct narratives that eventually converge in ways both unexpected and inevitable.</p>

            <p>The story follows fifteen-year-old Kafka Tamura, who runs away from home to escape an Oedipal prophecy, and Nakata, an elderly man who lost his ability to read and write after a mysterious childhood incident but gained the power to talk to cats. Their parallel journeys through contemporary Japan become a meditation on consciousness, identity, and the nature of reality itself.</p>

            <h2>The Metaphysical Landscape</h2>

            <p>Murakami constructs a world where the boundaries between the physical and metaphysical are permeable. Characters slip between dimensions, stones fall from the sky like rain, and spirits inhabit everyday objects. This surreal landscape serves as more than mere fantasy—it's a reflection of the characters' inner psychological states.</p>

            <blockquote>
                <p>"Sometimes fate is like a small sandstorm that keeps changing directions. You change direction but the sandstorm chases you."</p>
            </blockquote>

            <h2>Themes and Symbolism</h2>

            <p>The novel explores several recurring themes that are central to Murakami's work:</p>

            <ul>
                <li>The search for identity and self-discovery</li>
                <li>The power of music and literature as transformative forces</li>
                <li>The intersection of dreams and reality</li>
                <li>Isolation and human connection</li>
                <li>The weight of prophecy and free will</li>
            </ul>

            <h2>Literary Influences</h2>

            <p>The title itself references Franz Kafka, and the novel is peppered with allusions to classical literature, from Sophocles' "Oedipus Rex" to "The Tale of Genji". Murakami weaves these references seamlessly into his narrative, creating a rich tapestry that rewards careful readers.</p>

            <p>What makes "Kafka on the Shore" particularly compelling is its refusal to provide easy answers. Like a dream that lingers after waking, the novel leaves readers with questions that resonate long after the final page.</p>
        </article>
    </main>

    <footer>
        <p>© 2024 Literary Review Quarterly. All rights reserved.</p>
        <div class="social-links">Follow us on Uno | Subscribe to our newsletter</div>
    </footer>
</body>
</html>`;
        };

        function showError(message, isInfo = false) {
            const errorContainer = document.getElementById('errorContainer');
            // Convert newlines to <br> for multi-line error messages
            const formattedMessage = escapeHtml(message).replace(/\n/g, '<br>');
            const className = isInfo ? 'info' : 'error';
            errorContainer.innerHTML = `<div class="${className}">${formattedMessage}</div>`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        initializeTrek();
        
        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Cmd/Ctrl + Enter to extract
            if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                e.preventDefault();
                extractContent();
            }
            // Cmd/Ctrl + K to clear
            else if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                e.preventDefault();
                clearInput();
            }
        });
        
        // Enter key in URL input triggers fetch
        document.getElementById('urlInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                fetchUrl();
            }
        });
    </script>

    <script type="module">
        import * as ChriscoursesPerlinNoise from "https://esm.sh/@chriscourses/perlin-noise";

        // Editable values
        let showFPS = false; // Off by default for production
        let MAX_FPS = 30; // Limit FPS for performance
        let thresholdIncrement = 5;
        let thickLineThresholdMultiple = 3;
        let res = 12; // Slightly larger cells for performance
        let baseZOffset = 0.00005; // Slower movement for subtlety
        let lineColor = getComputedStyle(document.documentElement).getPropertyValue('--topograph-color').trim();

        let canvas;
        let ctx;
        let fpsCount = document.getElementById("fps-count");
        let frameValues = [];
        let inputValues = [];

        let currentThreshold = 0;
        let cols = 0;
        let rows = 0;
        let zOffset = 0;
        let zBoostValues = [];
        let noiseMin = 100;
        let noiseMax = 0;

        let mousePos = { x: -99, y: -99 };
        let mouseDown = false;

        // Update line color when theme changes
        const updateLineColor = () => {
            lineColor = getComputedStyle(document.documentElement).getPropertyValue('--topograph-color').trim();
        };

        // Listen for theme changes
        const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkModeMediaQuery.addEventListener('change', updateLineColor);

        setupCanvas();
        animate();

        function setupCanvas() {
            let canvasElement = document.getElementById('topograph-canvas');
            let canvasCtx = canvasElement.getContext('2d');

            if (!canvasCtx) {
                return;
            } else {
                canvas = canvasElement;
                ctx = canvasCtx;
            }
            canvasSize();
            window.addEventListener('resize', () => {
                canvasSize();
            });

            canvas.style.pointerEvents = 'auto';
            canvas.addEventListener('mousemove', (e) => {
                mousePos = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousedown', () => {
                mouseDown = true;
            });

            canvas.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            canvas.addEventListener('mouseleave', () => {
                mouseDown = false;
            });
        }

        function canvasSize() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            cols = Math.floor(canvas.width / res) + 1;
            rows = Math.floor(canvas.height / res) + 1;

            // Initialize zBoostValues
            for (let y = 0; y < rows; y++) {
                zBoostValues[y] = [];
                for (let x = 0; x <= cols; x++) {
                    zBoostValues[y][x] = 0;
                }
            }
        }

        function animate() {
            const startTime = performance.now();
            setTimeout(() => {
                const endTime = performance.now();
                const frameDuration = endTime - startTime;
                frameValues.push(Math.round(1000 / frameDuration));
                if (frameValues.length > 60 && showFPS) {
                    fpsCount.innerText = Math.round(frameValues.reduce((a, b) => a + b) / frameValues.length);
                    frameValues = [];
                }
                requestAnimationFrame(() => animate());
            }, 1000 / MAX_FPS);

            if (mouseDown) {
                mouseOffset();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            zOffset += baseZOffset;
            generateNoise();

            const roundedNoiseMin = Math.floor(noiseMin / thresholdIncrement) * thresholdIncrement;
            const roundedNoiseMax = Math.ceil(noiseMax / thresholdIncrement) * thresholdIncrement;
            for (let threshold = roundedNoiseMin; threshold < roundedNoiseMax; threshold += thresholdIncrement) {
                currentThreshold = threshold;
                renderAtThreshold();
            }
            noiseMin = 100;
            noiseMax = 0;
        }

        function mouseOffset() {
            let x = Math.floor(mousePos.x / res);
            let y = Math.floor(mousePos.y / res);
            if (inputValues[y] === undefined || inputValues[y][x] === undefined) return;
            const incrementValue = 0.002;
            const radius = 8;
            for (let i = -radius; i <= radius; i++) {
                for (let j = -radius; j <= radius; j++) {
                    const distanceSquared = i * i + j * j;
                    const radiusSquared = radius * radius;

                    if (distanceSquared <= radiusSquared && zBoostValues[y + i]?.[x + j] !== undefined) {
                        zBoostValues[y + i][x + j] += incrementValue * (1 - distanceSquared / radiusSquared);
                    }
                }
            }
        }

        function generateNoise() {
            for (let y = 0; y < rows; y++) {
                inputValues[y] = [];
                for (let x = 0; x <= cols; x++) {
                    inputValues[y][x] = ChriscoursesPerlinNoise.noise(x * 0.02, y * 0.02, zOffset + zBoostValues[y]?.[x]) * 100;
                    if (inputValues[y][x] < noiseMin) noiseMin = inputValues[y][x];
                    if (inputValues[y][x] > noiseMax) noiseMax = inputValues[y][x];
                    if (zBoostValues[y]?.[x] > 0) {
                        zBoostValues[y][x] *= 0.99;
                    }
                }
            }
        }

        function renderAtThreshold() {
            ctx.beginPath();
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = currentThreshold % (thresholdIncrement * thickLineThresholdMultiple) === 0 ? 1.5 : 0.75;

            for (let y = 0; y < inputValues.length - 1; y++) {
                for (let x = 0; x < inputValues[y].length - 1; x++) {
                    if (inputValues[y][x] > currentThreshold && inputValues[y][x + 1] > currentThreshold && inputValues[y + 1][x + 1] > currentThreshold && inputValues[y + 1][x] > currentThreshold) continue;
                    if (inputValues[y][x] < currentThreshold && inputValues[y][x + 1] < currentThreshold && inputValues[y + 1][x + 1] < currentThreshold && inputValues[y + 1][x] < currentThreshold) continue;

                    let gridValue = binaryToType(
                        inputValues[y][x] > currentThreshold ? 1 : 0,
                        inputValues[y][x + 1] > currentThreshold ? 1 : 0,
                        inputValues[y + 1][x + 1] > currentThreshold ? 1 : 0,
                        inputValues[y + 1][x] > currentThreshold ? 1 : 0
                    );

                    placeLines(gridValue, x, y);
                }
            }
            ctx.stroke();
        }

        function placeLines(gridValue, x, y) {
            let nw = inputValues[y][x];
            let ne = inputValues[y][x + 1];
            let se = inputValues[y + 1][x + 1];
            let sw = inputValues[y + 1][x];
            let a, b, c, d;

            switch (gridValue) {
                case 1:
                case 14:
                    c = [
                        x * res + res * linInterpolate(sw, se),
                        y * res + res
                    ];
                    d = [x * res, y * res + res * linInterpolate(nw, sw)];
                    line(d, c);
                    break;
                case 2:
                case 13:
                    b = [
                        x * res + res,
                        y * res + res * linInterpolate(ne, se)
                    ];
                    c = [
                        x * res + res * linInterpolate(sw, se),
                        y * res + res
                    ];
                    line(b, c);
                    break;
                case 3:
                case 12:
                    b = [
                        x * res + res,
                        y * res + res * linInterpolate(ne, se)
                    ];
                    d = [x * res, y * res + res * linInterpolate(nw, sw)];
                    line(d, b);
                    break;
                case 11:
                case 4:
                    a = [x * res + res * linInterpolate(nw, ne), y * res];
                    b = [
                        x * res + res,
                        y * res + res * linInterpolate(ne, se)
                    ];
                    line(a, b);
                    break;
                case 5:
                    a = [x * res + res * linInterpolate(nw, ne), y * res];
                    b = [
                        x * res + res,
                        y * res + res * linInterpolate(ne, se)
                    ];
                    c = [
                        x * res + res * linInterpolate(sw, se),
                        y * res + res
                    ];
                    d = [x * res, y * res + res * linInterpolate(nw, sw)];
                    line(d, a);
                    line(c, b);
                    break;
                case 6:
                case 9:
                    a = [x * res + res * linInterpolate(nw, ne), y * res];
                    c = [
                        x * res + res * linInterpolate(sw, se),
                        y * res + res
                    ];
                    line(c, a);
                    break;
                case 7:
                case 8:
                    a = [x * res + res * linInterpolate(nw, ne), y * res];
                    d = [x * res, y * res + res * linInterpolate(nw, sw)];
                    line(d, a);
                    break;
                case 10:
                    a = [x * res + res * linInterpolate(nw, ne), y * res];
                    b = [
                        x * res + res,
                        y * res + res * linInterpolate(ne, se)
                    ];
                    c = [
                        x * res + res * linInterpolate(sw, se),
                        y * res + res
                    ];
                    d = [x * res, y * res + res * linInterpolate(nw, sw)];
                    line(a, b);
                    line(c, d);
                    break;
                default:
                    break;
            }
        }

        function line(from, to) {
            ctx.moveTo(from[0], from[1]);
            ctx.lineTo(to[0], to[1]);
        }

        function linInterpolate(x0, x1, y0 = 0, y1 = 1) {
            if (x0 === x1) {
                return 0;
            }

            return y0 + ((y1 - y0) * (currentThreshold - x0)) / (x1 - x0);
        }

        function binaryToType(nw, ne, se, sw) {
            let a = [nw, ne, se, sw];
            return a.reduce((res, x) => (res << 1) | x);
        }
    </script>
</body>
</html>
